#!/usr/bin/env python3

# ------------------------------------------------------------------------------
# Contains code from the jpg re-encoder thumbnail post processor script:
# github.com/alexqzd/Marlin/blob/Gcode-preview/Display%20firmware/gcode_thumb_to_jpg.py
# ------------------------------------------------------------------------------

import base64 
import io
import os
import re
import sys
import traceback

from PIL import Image, ImageFilter

# Get the g-code source file name
sourceFile = sys.argv[1]

# Read the ENTIRE g-code file into memory
with open(sourceFile, "r") as f:
    lines = f.read()

thumbnailMatchExpression = r'(; thumbnail_JPG begin [0-9]+x[0-9]+ [0-9]+\n)((.|\n)*?)(; thumbnail_JPG end)'

thumbnailMatches = re.findall(thumbnailMatchExpression, lines)

if not thumbnailMatches:
    print('No thumbnail was detected in the original gcode.')
    print('Note that only JPG format is supported in the Ender 3 S1 Pro.')
    print('Ensure PrusaSlicer is generating a thumbnail and that the thumbnail is in JPG format.')
    print('The process will now exit. The PrusaSlicer gcode was not modified.')
    input('Press ener to exit.')
    sys.exit()


def encodedStringToGcodeComment(encodedString):
    chunks = 76
    return '; ' + '\n; '.join(encodedString[i:i+chunks] for i in range(0, len(encodedString), chunks)) + '\n'


def thumbnailFormatting(lines, thumbnailOriginalTextGroups):

    headOri = thumbnailOriginalTextGroups[0]
    thumbnailJPGOri = thumbnailOriginalTextGroups[1]
    tailOri = thumbnailOriginalTextGroups[-1]

    thumbnailFullTextOri = headOri + thumbnailJPGOri + tailOri

    lines = lines.replace(thumbnailFullTextOri, '')

    # Decoding, formatting and re-encoding the embbeded JPG
    encoded = thumbnailJPGOri.replace('; ', '')
    encoded = encoded.replace('\n', '')
    encoded = encoded.replace('\r', '')
    decoded = base64.b64decode(encoded)
    img_png = Image.open(io.BytesIO(decoded))
    img_png_rgb = img_png.convert('RGB')
    img_bbox = img_png_rgb.getbbox()
    img_x1 = img_bbox[0]
    img_y1 = img_bbox[1]
    img_x2 = img_bbox[2]
    img_y2 = img_bbox[3]
    img_bbox_x = img_x2-img_x1
    img_bbox_y = img_y2-img_y1
    if (img_bbox_x)>(img_bbox_y):
        img_y1 -= (img_bbox_x - img_bbox_y)/2
        img_y2 += (img_bbox_x - img_bbox_y)/2
    elif (img_bbox_x)<(img_bbox_y):
        img_x1 -= (img_bbox_y - img_bbox_x)/2
        img_x2 += (img_bbox_y - img_bbox_x)/2
    img_png_rgb = img_png_rgb.crop((img_x1, img_y1, img_x2, img_y2))
    img_png_rgb = img_png_rgb.resize((200, 200))
    img_png_rgb = img_png_rgb.filter(ImageFilter.DETAIL)
    img_byte_arr = io.BytesIO()
    img_png_rgb.save(img_byte_arr, format='jpeg', quality=95, optimize=False)
    img_byte_arr = img_byte_arr.getvalue()
    encodedjpg = base64.b64encode(img_byte_arr).decode('ascii')
    encodedjpg_gcode = encodedStringToGcodeComment(encodedjpg)

    # Building header
    width = 200
    height = 200

    x1 = (int)(width/80) + 1
    x2 = width - x1

    header = '; jpg begin {}*{} {} {} {} {}\n'.format(width, height, len(img_byte_arr), x1, x2, 240)

    # Building thumbnail jpg tail
    tail = '; jpg end\n'

    # Building the new full thumbnail
    thumbnailFullTextNew = header + encodedjpg_gcode + tail + ';\n\n'

    return lines, thumbnailFullTextNew


#Prepare header values
ph = re.search(r'; generated by (.*)\n', lines)
if ph is not None : lines = lines.replace(ph[0], '')

# Formattign estimated time
time = 0
match = re.search(r'; estimated printing time \(normal mode\) = (.*)\n', lines)
if match is not None :
    h = re.search(r'(\d+)h', match[1])
    h = int(h[1]) if h is not None else 0
    m = re.search(r'(\d+)m', match[1])
    m = int(m[1]) if m is not None else 0
    s = re.search(r'(\d+)s', match[1])
    s = int(s[1]) if s is not None else 0
    time = h*3600+m*60+s
else:
    input('There was an error reading the estimated time.\nPress any key to continue.')

# formatting used filament
match = re.search(r'; filament used \[mm\] = ([0-9.]+)', lines)
filament = 0
filament = float(match[1])/1000 if match is not None else input('There was an error reading the estimated filament.\nPress any key to continue.')

# Formatting object dimensions on build plate
match = os.getenv('SLIC3R_LAYER_HEIGHT')
layer = float(match) if match is not None else input('There was an error reading the layer height.\nPress any key to continue.')

minx = 0
miny = 0
minz = layer
maxx = 0
maxy = 0
maxz = (lines.count('BEFORE_LAYER_CHANGE') - 1) * layer

# Build new full gcode file text
newLines = ''

# Start with the thumbnails
for match in thumbnailMatches:
    lines, thumbnailFullTextNew = thumbnailFormatting(lines, match)
    newLines += thumbnailFullTextNew

# Continue with lines for printing data display
newLines += ';FLAVOR:Marlin\n'
newLines += ';TIME:{:d}\n'.format(time)
newLines += ';Filament used: {:.2f}m\n'.format(filament)
newLines += ';Layer height: {:.2f}\n'.format(layer)
newLines += ';MINX:{:.3f}\n'.format(minx)
newLines += ';MINY:{:.3f}\n'.format(miny)
newLines += ';MINZ:{:.3f}\n'.format(minz)
newLines += ';MAXX:{:.3f}\n'.format(maxx)
newLines += ';MAXY:{:.3f}\n'.format(maxy)
newLines += ';MAXZ:{:.3f}\n'.format(maxz)

# For gcode cleanliness
newLines += '\n;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n'
if ph is not None: newLines += ph[0]
lines = lines.replace('\n\n;\n\n;\n; \n\n\n\n\n\n', '')
lines = lines.replace('\n\n;\n\n;\n; \n', '')

# Rest of gcode
newLines += lines

# Write all data to file
with open(sourceFile, 'w+') as of:
    of.write(newLines)